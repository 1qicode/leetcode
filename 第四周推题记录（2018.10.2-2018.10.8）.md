### 第四周推题记录（2018.10.2-2018.10.8）

2018.10.2（Simon)

https://leetcode.com/problems/same-tree/

题解1：

```c++
//by Thor
/* Definition for a binary tree node.
struct TreeNode {
int val
TreeNode *left;
TreeNode *right;
TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
*/
class Solution {
public:
	bool isSameTree(TreeNode* p, TreeNode* q) {    
		if(p==NULL&&q==NULL)
            return true; 
	    if((p==NULL&&q!=NULL)||(p!=NULL&&q==NULL))
            return false;   
		if(p->val!=q->val)
            return false;  
		return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right);
        }
};
```



2018.10.3(Simon)

https://leetcode.com/problems/insertion-sort-list/

题解1：

```c++
//by Simon
/**
Definition for singly-linked list.
struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(NULL) {}
};
*/
class Solution {
	public:
        ListNode* insertionSortList(ListNode* head) {
            if(head == NULL || head->next == NULL) return head;
            ListNode* newHead = new ListNode(-1);
            newHead->next = head;
            ListNode* cp = newHead->next;
            //compare pointer
            ListNode* pre = newHead;
            ListNode* p = head->next;
            head->next =  NULL;
            while(p){
                ListNode* tp = p;//get current one;
                p = p->next;//remark next one;
                tp->next = NULL;//disconnect;
                while(cp != NULL && tp->val > cp->val){
                    pre = cp;
                    cp = cp->next;
                }
                //now cp get the last sorted one or cp->val > p->val
                //insert tp after pre and before cp;
                tp->next = cp;
                pre->next = tp;
                if(cp == newHead->next)
                    //change new head element;
                    newHead = pre;
                cp = newHead->next;//back to the first element;
                pre = newHead;
            }
         return newHead->next;
    }
}
```

题解2：

```c++
//by Thor`
/**
Definition for singly-linked list.
	struct ListNode {
	int val;
	ListNode *next;
	ListNode(int x) : val(x), next(NULL) {}
};
*/
class Solution {
    public:
    ListNode* insertionSortList(ListNode* head) {
        if(!head)return NULL;
    	ListNode* hd=new ListNode(0);
    	hd->next=head;
        for(ListNode* p=head;p->next;){
            if(p->next->val<p->val){
            	for(ListNode* q=hd;;q=q->next)
            		if(p->next->val<q->next->val){
            			ListNode* t=p->next->next;
            			p->next->next=q->next;
            			q->next=p->next;
            			p->next=t;
            			break;        		
                    }
            }
            else p=p->next;
        }
        return hd->next;
    }
};
```

208.10.4(Thor)

今日推题：
https://leetcode.com/problems/search-in-rotated-sorted-array/description

题解1：

```c++
//by Thor
class Solution {
public:
    int search(vector<int>& nums, int target) {
    	int le=0,ri=(int)nums.size()-1;
        while(le <= ri){
        int mid=(le+ri)>>1;
     	if(target==nums[le])return le;
    	if(target==nums[ri])return ri;
        if(target==nums[mid])return mid;
        if(nums[le]<nums[mid])
            if(nums[le]<=target&&target<=nums[mid])
                ri=mid-1;
           	else le=mid+1;
        else if(nums[mid]<=target&&target<=nums[ri])
            le=mid+1;
        else ri=mid-1;
     }
      return -1;
  }
};
```


​        由于题目说了，整个列表是个环状有序的，所以我一开始的想法就是，找到那个奸细，他前面都是大的一段，后面的都是小的一段，这样找奸细一个二分，然后再在前面或者后面找又需要一个二分，就两个二分解决了 .后来我拜读了一下zzb大佬的代码，发现真是台厉害了！可以一个二分就搞完，可是我读不懂他神秘的case 1和case 2，于是我被迫自己开始想（大家可以艾特他出来让他真情吐露）。然后就想到了上面这个3个if4种情况的代码。其实不难发现，如果nums[le] < nums [mid]，那么前面一段必是大的一段，如果target在它们中间，那么无论如何都要在这一段找，否则无论如何都在后面一段找。nums[mid]<nums[ri]的情况类似。所以我们会发现，这个过程还是一个二分可以解决的，所以就愉快地写出了上面这个肥硕的代码。

题解2：

2018.10.5（毒液哥）

https://leetcode.com/problems/reverse-pairs/ 

题解1：

```c++
//by Thor
class Solution {
public:
    int ans;
    int a[50010],b[50010];
    void Dfs(int le,int ri)
    {
       if(le==ri)return;
       int mid=(le+ri)>>1;
       Dfs(le,mid);
       Dfs(mid+1,ri);
       int la=mid;
       for(int i=le;i<=mid;i++){
            while(la<ri&&a[i]>2ll*a[la+1])la++;
            ans+=la-mid;
       }
       int i=le,j=mid+1,p=le-1;
       while(i<=mid&&j<=ri)
           if(a[i]<a[j])b[++p]=a[i++];
           else b[++p]=a[j++];
       while(i<=mid)b[++p]=a[i++];
       while(j<=ri)b[++p]=a[j++];
       for(int i=le;i<=ri;i++)a[i]=b[i];
    }
    int reversePairs(vector<int>& nums) {
        if(nums.size()==0)return 0;
        ans=0;
        int n=nums.size();
        for(int i=1;i<=n;i++)
        	a[i]=nums[i-1];
        Dfs(1,n);
        return ans;
    }
};
```

2018.10.6(王昊)

https://leetcode.com/problems/basic-calculator-ii/description/

题解1：

```c++
//by Thor
class Solution {
public:
    int Get(char ch)
    {
        switch(ch)
        {
            case '+': return 1;
            case '-': return 2;
            case '*': return 3;
            case '/': return 4;
        }
    }
    int Cal(int x,int op,int y)
    {
        switch(op)
        {
            case 1: return x+y;
            case 2: return x-y;
            case 3: return x*y;
            case 4: return x/y;
        }
    }
    #define maxn 100000
    int num[maxn];
    int op[maxn];
    int calculate(string s) {
        int _n=(int)s.size();
        int x=0;
        int n=0;
        for(int i=0;i<_n;i++)
           if(s[i]!=' ')
                s[n++]=s[i];
        for(int i=0;i<n;i++)
        {
            if(s[i]=='+'||s[i]=='-'||s[i]=='*'||s[i]=='/')
            {
                int pri=Get(s[i]);
                if(op[0]&&op[op[0]]>2)
                    x=Cal(num[num[0]--],op[op[0]--],x);
                num[++num[0]]=x;
                op[++op[0]]=pri;
                x=0;
            }
            else x=x*10+s[i]-'0';
       }
        if(op[0]&&op[op[0]]>2)
            x=Cal(num[num[0]--],op[op[0]--],x);
        num[++num[0]]=x;
        x=num[1];
        for(int i=1;i<=op[0];i++)
            x=Cal(x,op[i],num[i+1]);
        return x;
    }
};
```

题解2：

```c++
//by hazelnut
enum Type{
    INT,
    ADD,
    SUB,
    MUL,
    DIV
};

class Solution {
public:
    Type checkType(char ch) {
        if (ch >= '0' && ch <= '9') return INT;
        if (ch == '*') return MUL;
        if (ch == '/') return DIV;
        if (ch == '+') return ADD;
        if (ch == '-') return SUB;
    }
    int calculate(string s) {
        stack<int> numberSt;
        int index = 0;
        int ret = 0;
        while(index < s.size()) {
            while(index < s.size() && s[index] == ' ') index += 1;
            if (index == s.size()) return ret;
            Type type = checkType(s[index]);
            if (type != INT) index += 1;
            int nextNumber = extractNumber(s, index);
            int top;
            switch(type) {
                case INT:
                    numberSt.push(nextNumber);
                    break;
                case MUL:
                    top = numberSt.top();
                    numberSt.pop();
                    numberSt.push(top * nextNumber);
                    break;
                case DIV:
                    top = numberSt.top();
                    numberSt.pop();
                    numberSt.push(top / nextNumber);
                    break;
                case ADD:
                    numberSt.push(nextNumber);
                    break;
                case SUB:
                    numberSt.push(-nextNumber);
                    break;
            }
        }
        while(numberSt.size() >= 2) {
            int right = numberSt.top();
            numberSt.pop();
            int left = numberSt.top();
            numberSt.pop();
            numberSt.push(left + right);
        }
        return numberSt.top();
    }
    int extractNumber(string& s, int& index) {
    while(index < s.size() && s[index] == ' ') index += 1;
    int ret = 0;
    while (index < s.size()
           && s[index] <= '9'
           && s[index] >= '0') {
        ret  = ret * 10 + (s[index] - '0');
        index += 1;
   }
    while(index < s.size() && s[index] == ' ') index += 1;
    return ret;
}
};
```



2018.10.7(Oxer)

https://leetcode-cn.com/problems/gray-code/

题解1:

```c++
//by Ryan
class Solution {
private:
    void dfs(vector<int> &ans,string cur,int n,bool index){
        if(n<=0){
            int answer=0;
            for(int i=0;i<cur.size();i++)
                if(cur[i]=='1')
                    answer+=pow(2,  (cur.size()-1-i));
            ans.push_back(answer);
            return;
        }
        if(index==0){
            dfs(ans,cur+'0',n-1,index);
            dfs(ans,cur+'1',n-1,!index);
        }
        else{
            dfs(ans,cur+'1',n-1,!index);
            dfs(ans,cur+'0',n-1,index);
        }
}

public:
    vector<int> grayCode(int n) {
        if(n==0) return vector<int>(1,0);
        vector<int> ans;
        string cur;
        bool index=0;
        dfs(ans,cur,n,index);
        return ans;
    }
};
```

题解2：

```c++
// by Oxer
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;
        for (int i=0;i<1<<n;i++)
        {
            int x=i&(1<<n-1);
            for (int j=n-2;j>=0;j--)
              x|=(((i>>j+1)&1)^((i>>j)&1))<<j;
            ans.push_back(x);
        }
        return ans;
    }
};
```

2018.10.8(Gromah)

https://leetcode.com/problems/h-index-ii/

题解1：

```c++
//by Gromah
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int sz = int(citations.size()), l = 0, r = sz;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (citations[sz - mid] >= mid)
                l = mid;
            else r = mid - 1;
        }
        return l;
    }
};
```

